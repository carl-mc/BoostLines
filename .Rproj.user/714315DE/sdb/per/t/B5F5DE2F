{
    "collab_server" : "",
    "contents" : "// [[Rcpp::depends(BH)]]\n\n\n// MNEMONICS\n#include <vector>\n#include <Rcpp.h>\n#include <boost/geometry/geometry.hpp>\n#include <boost/geometry/geometries/linestring.hpp>\n#include <boost/geometry/geometries/point_xy.hpp>\n#include <boost/assign/list_of.hpp>\nusing namespace Rcpp;\nnamespace bg = boost::geometry;\n\n\n// TYPEDEFS & CLASSES\ntypedef bg::model::d2::point_xy<double> point;\ntypedef bg::model::linestring<point> line;\nclass line_collection : public std::vector<line>{\n};\nstruct dpoint {\n\n  dpoint(point inp, double indist) {\n    p = inp;\n    dist = indist;\n  }\n\n  point p;\n  double dist;\n};\nstruct closest {\n  bool operator()(dpoint const &a, dpoint const &b) {\n    return a.dist < b.dist;\n  }\n};\n\n\n\n// R CONSTRUCTORS\nline make_line(NumericMatrix coord) {\n\n  line new_line;\n  for (int i=0; i < coord.nrow(); i++) {\n    new_line.push_back(bg::make<point>(coord(i,0), coord(i,1)));\n  }\n\n  return(new_line);\n}\n\nline_collection make_lc(List coord_ls) {\n\n  line_collection lc;\n  for (int i = 0; i < coord_ls.size(); i++) {\n    line new_line = make_line(coord_ls(i));\n    lc.push_back(new_line);\n  }\n  return(lc);\n}\n\n\n\n// NODING\nbool point_within (const point &p, const line & l, const point &startpoint, const point &endpoint) {\n\n  bool ret = bg::intersects(p, l) & !bg::intersects(startpoint, p) & !bg::intersects(endpoint,p);\n  return(ret);\n\n}\n\nline_collection break_line_on_points (const line &l, const std::vector<point> &pvec) {\n\n  std::vector<point> pvec_unique;\n  std::unique_copy(pvec.begin(), pvec.end(), std::back_inserter(pvec_unique), boost::geometry::equal_to<point>());\n\n  int line_len = l.size();\n  int num_points = pvec_unique.size();\n\n  line_collection out_lc;\n  line ongoing_line;\n  ongoing_line.push_back(l[0]);\n\n  for (int i = 0; i < line_len - 1; i++) {\n    line this_segment;\n    point segment_start_point = l[i];\n    point segment_end_point = l[i+1];\n    this_segment.push_back(segment_start_point);\n    this_segment.push_back(segment_end_point);\n\n    // Get points on segment and their distance from this point\n    // Also check whether any of the break points lie on segment end point\n    bool any_intersects_endpoint = false;\n    std::vector<dpoint> points_on_segment;\n    for (int k = 0; k < num_points; k++) {\n      point this_break_point = pvec_unique[k];\n\n      if (point_within(this_break_point, this_segment, segment_start_point, segment_end_point)) {\n        double dist = bg::distance(segment_start_point, this_break_point);\n        dpoint this_dpoint(this_break_point, dist);\n        points_on_segment.push_back(this_dpoint);\n      } else {\n        if (!any_intersects_endpoint) {\n          any_intersects_endpoint = bg::intersects(segment_end_point, this_break_point);\n        }\n      }\n    }\n\n    // Make new segments in order\n    if (points_on_segment.size() > 0) {\n\n      // Sort points on segment\n      std::sort(points_on_segment.begin(), points_on_segment.end(), closest());\n\n      for (int k = 0; k < points_on_segment.size(); k++) {\n        // Checkout current line\n        point this_break_point = points_on_segment[k].p;\n        ongoing_line.push_back(this_break_point);\n        line finished_line = ongoing_line;\n        out_lc.push_back(finished_line);\n        // Start new line\n        ongoing_line.clear();\n        ongoing_line.push_back(this_break_point);\n      }\n    }\n\n    // Add segment end point to ongoing line\n    ongoing_line.push_back(segment_end_point);\n\n    if (i == line_len - 2) {\n      // If this is the last segment: checkout current line\n      line finished_line = ongoing_line;\n      out_lc.push_back(finished_line);\n    } else {\n      // If a break point intersects with segment end point:\n      // Checkount ongoing line and start new one\n      if (any_intersects_endpoint) {\n        line finished_line = ongoing_line;\n        out_lc.push_back(finished_line);\n        ongoing_line.clear();\n        ongoing_line.push_back(segment_end_point);\n      }\n    }\n  }\n\n  return(out_lc);\n}\n\nline_collection break_line_on_line (const line &l1, const line &l2) {\n  // Does not break lines with overlapping segments!\n\n  line_collection broken_lc;\n  if (bg::intersects(l1, l2) & !bg::overlaps(l1, l2)) {\n\n    std::vector<point> intersection_points;\n    bg::intersection(l1, l2, intersection_points);\n    broken_lc = break_line_on_points(l1, intersection_points);\n\n  } else {\n\n    line copy_line = l1;\n    broken_lc.push_back(copy_line);\n\n  }\n\n  return(broken_lc);\n}\n\nline_collection break_line_on_line_collection (const line &l, const line_collection &breaker_lc) {\n  // Ignores collinear segments\n\n  line_collection input_lc;\n  line_collection output_lc;\n  input_lc.push_back(l);\n\n  for (int i = 0; i < breaker_lc.size(); i++) {\n\n    line this_breaker = breaker_lc[i];\n\n    for (int j = 0; j < input_lc.size(); j++) {\n\n      line this_line = input_lc[j];\n\n      if (bg::intersects(this_line, this_breaker)) {\n\n        line_collection broken_blc = break_line_on_line(this_line, this_breaker);\n        for (int k = 0; k < broken_blc.size(); k++) {\n          output_lc.push_back(broken_blc[k]);\n        }\n\n      } else {\n        output_lc.push_back(this_line);\n      }\n    }\n\n    input_lc = output_lc;\n    output_lc.clear();\n  }\n\n  return(input_lc);\n}\n\nList node_lc (const line_collection &in_lc) {\n  // Ignores collinear segments\n\n  int n_lines = in_lc.size();\n  line_collection out_lc;\n  std::vector<int> indices;\n\n  for (int i = 0; i < n_lines; i++) {\n\n    line this_line = in_lc[i];\n    line_collection breaker_lc(in_lc);\n    breaker_lc.erase(breaker_lc.begin() + i);\n\n    line_collection broken_lc = break_line_on_line_collection(this_line, breaker_lc);\n\n    for (int j = 0; j < broken_lc.size(); j++) {\n      out_lc.push_back(broken_lc[j]);\n      indices.push_back(i+1); // R indexing\n    }\n  }\n\n  IntegerVector indices_nv = wrap(indices);\n  List out_ls = List::create(out_lc, indices_nv);\n\n  return(out_ls);\n}\n\n\n// OTHER GEOMETRIC OPERATIONS\nLogicalMatrix intersects_lc(const line_collection &lc) {\n\n  int n_lines = lc.size();\n  LogicalMatrix lm(n_lines, n_lines);\n  lm.fill(false);\n  for (int j = 0; j < n_lines; j++) {\n    for (int i = j; i < n_lines; i++) {\n      bool cr;\n      if (i != j) {\n        line l_i = lc[i];\n        line l_j = lc[j];\n        cr = bg::intersects(l_i, l_j);\n      } else {\n        cr = true;\n      }\n      lm(i,j) = cr;\n      lm(j,i) = cr;\n    }\n  }\n\n  return(lm);\n}\n\nNumericMatrix distance_lc(const line_collection &lc) {\n\n  int n_lines = lc.size();\n  NumericMatrix dm(n_lines, n_lines);\n  dm.fill(0);\n  for (int j = 0; j < n_lines; j++) {\n    for (int i = j; i < n_lines; i++) {\n      if (i != j) {\n        line l_i = lc[i];\n        line l_j = lc[j];\n        double d = bg::distance(l_i, l_j);\n        dm(i,j) = d;\n        dm(j,i) = d;\n      }\n    }\n  }\n\n  return(dm);\n}\n\n\n\n// R UNPACKERS\nList unpack_lc(const line_collection &lc) {\n\n  int n_lines = lc.size();\n  List coord_ls(n_lines);\n\n  for (int i = 0; i < n_lines; i++) {\n    line this_line = lc[i];\n    int len = this_line.size();\n    NumericMatrix this_coord(len, 2);\n    for (int j = 0; j < len; j++) {\n      this_coord(j,0) = this_line[j].x();\n      this_coord(j,1) = this_line[j].y();\n    }\n    coord_ls(i) = this_coord;\n  }\n\n  return coord_ls;\n}\n\n\n// RCPP STUFF\nRCPP_EXPOSED_CLASS(line_collection)\nRCPP_MODULE(mod) {\n  class_<line_collection>( \"line_collection\" );\n  function( \"make_lc\", &make_lc );\n  function( \"unpack_lc\", &unpack_lc );\n  function( \"node_lc\", &node_lc );\n  function( \"intersects_lc\", &intersects_lc );\n  function( \"distance_lc\", &distance_lc );\n}\n",
    "created" : 1490016028451.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3184921154",
    "id" : "B5F5DE2F",
    "lastKnownWriteTime" : 1490023921,
    "last_content_update" : 1490023921464,
    "path" : "~/Projects/BoostLines/BoostLines/src/boost_lines.cpp",
    "project_path" : "src/boost_lines.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}